<!DOCTYPE html>
<!-- saved from url=(0013)about:internet -->
<html lang="ja">
<head>

<meta charset="UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Script-Type" content="text/javascript" />

<title>index</title>

<meta name="viewport" content="width=device-width" />

<!--
<link rel="stylesheet" href="css/style.css" media="all" />
-->
<style type="text/css">

* {
	-moz-box-sizing:border-box;
	-webkit-box-sizing:border-box;
	-o-box-sizing:border-box;
	-ms-box-sizing:border-box;
	box-sizing:border-box;
}

/*
html {
	margin:0;
	height:100%;
}
*/
body {
/*
	margin:0;
	height:100%;
*/
	background: #f0f0e0;
	color: #0f0f1f;
	font-family:"Helvetica Neue", Helvetica, "Arial Unicode MS", Arial, sans-serif;
	/*/
	font-family:monospace;/**/
}

main {
	margin:1ex;
}

.statistics tr td {
	width:24ex;
}
.dashed {
	border:dashed 1px #333;
}

#out_log1 {
	height:4em;
	overflow-y:scroll;
	resize:vertical;
	border-style:inset;
	font-family:monospace;
}

</style>
<script type="text/javascript">//<!-- type="application/javascript;version=1.7"-->
// <![CDATA[




function mtof(midi){
	// midiノード番号を周波数に変換
	// MIDIノート番号:60 = 周波数:256Hz = ド
	// MIDIノート番号:69 = 周波数:440Hz = 標準A = ラ
	// 可聴域:20Hz～20,000Hz
	return 440 * 2 ** ((midi - 69) / 12);
}
function tdur(tempo, length){
	// テンポ, 音符
	return (60 / tempo) * (4 / length);
}

function logN(x, base){	// JavaScriptでは底を指定した対数が使えないため
	return Math.log(x) / Math.log(base);
}


function encodeExHamming(input){
	// 引数:文字列or配列(複数対応), 戻り値:文字列
	let output = [];
	if(!Array.isArray(input)){
		input = input.split("");
	}
	for(let i=0,len=input.length; i<len; i+=4){
		let buffer = input.slice(i, i+4);	//input.splice(0, 4);
		buffer.push(String(+buffer[0] ^ +buffer[2] ^ +buffer[3]));
		buffer.push(String(+buffer[0] ^ +buffer[1] ^ +buffer[3]));
		buffer.push(String(+buffer[1] ^ +buffer[2] ^ +buffer[3]));
		buffer.push("" + buffer.reduce((acc, cur) => +cur ^ acc));	// even パリティ
		output = output.concat(buffer);
	}
	return output.join("");
}

function decodeExHamming(input){
	// 引数:文字列or配列(複数対応), 戻り値:文字列
	let output = [];
	if(!Array.isArray(input)){
		input = input.split("");
	}
	if(input.length%8 != 0){
		return output.join("");
	}
	for(let i=0,len=input.length; i<len; i+=8){
		let buffer = input.slice(i, i+8);	//input.splice(0, 8);
		let check = [];
		check.push(+buffer[0] ^ +buffer[2] ^ +buffer[3] ^ +buffer[4]);
		check.push(+buffer[0] ^ +buffer[1] ^ +buffer[3] ^ +buffer[5]);
		check.push(+buffer[1] ^ +buffer[2] ^ +buffer[3] ^ +buffer[6]);
		check.push(buffer.reduce((acc, cur) => +cur ^ acc));
		
		if(check[0]+check[1]+check[2] >= 1 && check[3] == 0){
			// エラー
			//output = output.concat(["[error]","","",""]);
			output = [];	//["error"];
			break;
		}
		else{
			if(check[0]+check[1]+check[2] <= 1){
				// 訂正不要
			}
			else if(check[0]+check[1]+check[2] == 3){
				buffer[3] = String(+!+buffer[3]);
			}
			else{
				buffer[(check.indexOf(0)+1)%3] = String(+!+buffer[(check.indexOf(0)+1)%3]);
			}
			output = output.concat(buffer.splice(0, 4));
		}
	}
	return output.join("");
}


function encode(text, base=10){
	let result = encodeURIComponent(text)
		.match(/%[0-9A-F]{2}|[^%]/g)
		.map(e => (e.substr(0,1)=="%" ? parseInt(e.slice(1),16) : e.charCodeAt(0)));	// 10進数値配列
	
	if(base != 10){
		//result = result.map(e => ("0".repeat(logN(2**8,base))+e.toString(base)).slice(-logN(2**8,base)));	// n進文字列配列
		result = result.map(e => e.toString(base).padStart(logN(2**8, base), 0));	// n進文字列配列
	}
	
	return result.join("");	// n進文字列
}

function decode(text, base=16){
	let result = "";
	for(let i=0,step=logN(2**8,base); i<text.length; i+=step){
		result += "%" + parseInt(text.substr(i, step), base).toString(16).padStart(2, 0);	// n進文字列⇒16進文字列
	}
	
	try{
		result = decodeURIComponent(result);
	}
	catch(e){
		result = "";
	}
	
	return result;
}



function createStat(length=20){
	let data = [];
	return function(){
		let mean = 0;
		let median = 0;
		let stdev = 100;

		data.push(this.value);
		if(data.length > length){
			data.shift();
			let sorted = data.slice().sort((a, b) => a - b);
			mean = data.slice(-data.length).reduce((pre, curr, i) => pre + curr, 0) / data.length;	// 末尾から指定要素数を抜き出し平均取得
			median = (sorted[Math.floor(data.length / 2)] + sorted[Math.ceil(data.length / 2)]) / 2;
			stdev = Math.sqrt(data.reduce((sum, curr, i) => sum + (curr - mean) ** 2, 0) / (data.length - 1));	// 不偏標準偏差(標本標準偏差)
		}
		
		this.mean = mean;
		this.median = median;
		this.stdev = stdev;
	}
}

function createFIR(length=20, averageSize=7){
	let data = [];
	let coef = [];	// 係数:coefficient
	return function(x){
		data.push(x);
		if(data.length > length){
			data.shift();
		}
		
		if(data.length > averageSize){
			// 配列末尾から指定要素数を抜き出し平均取得
			return data.slice(-averageSize).reduce((pre, curr, i) => (pre + curr * coef[averageSize-i-1]), 0);
		}
		else{
			return 0;
		}
	}
}



function windowfunc(data){
	if(!windowfunc.weights){
		windowfunc.weights = Array(length);
		for(let i=0,len=data.length; i<len; i++){
			windowfunc.weights[i] = 0.5-0.5*Math.cos(2*i*Math.PI/len);
		}
	}
	
	let result = Array(data.length);
	for(let i=0,len=data.length; i<len; i++){
		result[i] = data[i] * windowfunc.weights[i];
	}
	return result;
}

function LPFilter(data){
	let result = Array(data.length);
	for(let i=0,len=data.length; i<len; i++){
		result[i] = (data[Math.max(i-1,0)] + data[i] + data[Math.min(i+1,len-1)]) / 3;
	}
	return result;
}

function DFT(data, frec=[]){	// frecに設定された添字番号が2つなら範囲指定、3つ以上なら該当番号のみ返す
	// first-last, begin-end, start-stop/finish
	let length = data.length;
	let start = frec.length>0 ? frec[0] : 0;
	let end = frec.length>0 ? frec[frec.length-1] : length/2;
	
	if(!DFT.weights){
		DFT.weights = {};
		DFT.weights.re = Array(length);
		DFT.weights.im = Array(length);
		for(let i=0; i<length/2; i++){
			DFT.weights.re[i] = Array(length);
			DFT.weights.im[i] = Array(length);
			for(let j=0; j<length; j++){
				DFT.weights.re[i][j] = Math.cos(2*i*j*Math.PI/length);
				DFT.weights.im[i][j] = -Math.sin(2*i*j*Math.PI/length);
			}
		}
	}
	
	let spectrums = {};
	spectrums.re = Array(length);
	spectrums.im = Array(length);
	spectrums.abs = Array(length);
	spectrums.arg = Array(length);
	
	if(frec.length <= 2)
		frec = Array(end - start + 1).fill(start).map((x, y) => x + y);	// range(start,end+1)
	
	frec.forEach(function(i){	//for(let i=start; i<end; i++)
		spectrums.re[i] = 0;
		spectrums.im[i] = 0;
		for(let j=0; j<length; j++){
			let w_re = DFT.weights.re[i][j];	// Math.cos(2*i*j*Math.PI/length);
			let w_im = DFT.weights.im[i][j];	// -Math.sin(2*i*j*Math.PI/length);
			spectrums.re[i] += w_re * data[j];
			//spectrums.re[i] -= w_im * data.im[j];		// 入力データに虚数部が存在する場合
			spectrums.im[i] += w_im * data[j];
			//spectrums.im[i] += w_re * data.im[j];		// 入力データに虚数部が存在する場合
		}
		spectrums.abs[i] = Math.hypot(spectrums.re[i], spectrums.im[i]);	// Math.sqrt(spectrums.re[i]**2 + spectrums.im[i]**2);
		spectrums.abs[i] = Math.log2(spectrums.abs[i] / 2) * 10;
		spectrums.arg[i] = Math.atan2(spectrums.im[i], spectrums.re[i]) / Math.PI;	// -1～+1
	});
	
	return spectrums;
}






//oscillator.type = {"sine":サイン波, "square":矩形波, "sawtooth":鋸歯状波, "triangle":三角波}
//oscillator.frequency = 440Hz	0～±ナイキスト周波数(サンプリング周波数の1/2=22050Hz)	負数は逆位相
//oscillator.detune = 0セント	約-153600～+153600	1200セント=1オクターブ
function send(source){
	const bps = 0.25;	// シンボル間隔 = ΔT + GI(ガードインターバル)		1シンボルあたり同期信号の半周期のタイミングで送信
	let audioContext = new (AudioContext || webkitAudioContext)();
	
	let compressor = audioContext.createDynamicsCompressor();	// クリッピング(振幅値のオーバーフロー)による歪みを防止
	//let gain = audioContext.createGain();
	compressor.connect(audioContext.destination);	// スピーカー(context.destination)に接続
	
	let oscillators = {
		sync : [
			{oscillator:audioContext.createOscillator(), gain:audioContext.createGain(), freq:[18000, -18000]},	// PSK
			{oscillator:audioContext.createOscillator(), gain:audioContext.createGain(), freq:[19500, 19875]},
			{oscillator:audioContext.createOscillator(), gain:audioContext.createGain(), freq:[20625, 20250]},
		],
		data : [
			{oscillator:audioContext.createOscillator(), gain:audioContext.createGain(), freq:[18750, -18750]},	// PSK
			{oscillator:audioContext.createOscillator(), gain:audioContext.createGain(), freq:[21375, 21750]},
		],
		check : [
			{oscillator:audioContext.createOscillator(), gain:audioContext.createGain(), freq:[22500, 22875]},
		],
	};
	
	let payload = [0,1,0,1,1,0,0,1].concat(encodeExHamming(encode(source, 2)).split(""));
	let preamble = [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,1,1,0,1,1,0,0, 0,1,1,0,1,1,0,0];	// プリアンブル + 同期ワード(Start of Frame Delimiter(SFD):開始フレーム識別子,フレーム開始デリミタ)
	let type = [0,1,1,1,0,0,1,0, 0,0,0,0,0,0,0,0];
	let size = [0,0,1,1,0,1,0,1].concat(encodeExHamming((payload.length/8).toString(2).padStart(8*4/2, 0)).split(""));
	//let fcs = [0,0,1,0,1,0,1,1];
	let frame = preamble.concat(type).concat(size).concat(payload);
	
	let t_start = audioContext.currentTime;
	let t = t_start;
	frame.forEach((bit, i) => {
		// データ信号,同期信号
		oscillators.sync.forEach(e => {
			e.oscillator.frequency.setValueAtTime(e.freq[i%2], t);
			e.gain.gain.setValueAtTime(0.1, t);	// GI(ガードインターバル)
			e.gain.gain.setValueAtTime(1.0, t + bps/5);
		});
		oscillators.data.forEach(e => {
			e.oscillator.frequency.setValueAtTime(e.freq[bit], t);
			e.gain.gain.setValueAtTime(0.1, t);	// GI(ガードインターバル)
			e.gain.gain.setValueAtTime(1.0, t + bps/5);
		});
		//oscillators.check.forEach(e => {
		//	e.oscillator.frequency.setValueAtTime(e.freq[encodeHamming(frame)[i]], t);
		//	e.gain.gain.setValueAtTime(0.1, t);	// GI(ガードインターバル)
		//	e.gain.gain.setValueAtTime(1.0, t + bps/5);
		//});
		t += bps;
		
		document.querySelector("#in_progressive").innerHTML += "<span>" + bit + "</span>" + ((i+1)%4 ? "" : " ");
		setTimeout((i => {
			return () => {
				document.querySelectorAll("#in_progressive span")[Math.max(i-1, 0)].style.backgroundColor = "#ccc";
				document.querySelectorAll("#in_progressive span")[i].style.backgroundColor = "#ff0";
			};
		})(i), (t-audioContext.currentTime)*1000);
	});
	
	oscillators.sync.forEach(e => {
		e.oscillator.connect(e.gain);
		e.gain.connect(compressor);
	});
	oscillators.data.forEach(e => {
		e.oscillator.connect(e.gain);
		e.gain.connect(compressor);
	});
	//oscillators.check.forEach(e => {
	//	e.oscillator.connect(e.gain);
	//	e.gain.connect(compressor);
	//});
	
	oscillators.sync.forEach(e => {
		e.oscillator.start(t_start);
		e.oscillator.stop(t);
	});
	oscillators.data.forEach(e => {
		e.oscillator.start(t_start);	// + bps * preamble.length
		e.oscillator.stop(t);
	});
	//oscillators.check.forEach(e => {
	//	e.oscillator.start(t_start);
	//	e.oscillator.stop(t);
	//});
}



function receive(){
	navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;	//navigator.mediaDevices.getUserMediaに置き換えられた
	
	// 端末のビデオ、音声ストリームを取得
	navigator.getUserMedia(
		{audio:true, video:false},
		function(stream){
			// audioContext.sampleRate	サンプリングレート(周波数)	1秒間に実行する標本化処理の回数		48,000Hz or 44,100Hz
			// bufferSize / n = (frequencyBinCount = spectrums.length = ナイキスト周波数) = fftSize / 2
			
			const bufferSize = 1024;	// 1024:0.02sごと
			let audioContext = new (AudioContext || webkitAudioContext)();
			let mediaStreamSource = audioContext.createMediaStreamSource(stream);
			let scriptProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);	// 256~16384	ScriptProcessorをAudioWorkletに切り替える必要有
			let audioAnalyser = audioContext.createAnalyser();
			
			audioAnalyser.smoothingTimeConstant = 0.0;	// 0.8:0.0～1.0	分析フレームの平均間隔を表す値で、使用例として時間的にスペクトルを平滑化させるのに用いられる
			audioAnalyser.fftSize = bufferSize * 2;	// 2048:32,64,128,256,512,1024,2048,4096,8192,16384,32768
			//audioAnalyser.maxDecibels	// 結果の範囲の最大値
			//audioAnalyser.minDecibels	// 結果の範囲の最小値
			let fsDivN = audioContext.sampleRate / audioAnalyser.fftSize;	// 23.4375=48000/2048
			
			let canvas0 = document.querySelector("#canvas0");
			let canvas1 = document.querySelector("#canvas1");
			let canvas2 = document.querySelector("#canvas2");
			let canvas3 = document.querySelector("#canvas3");
			let canvasContext0 = canvas0.getContext('2d');
			let canvasContext1 = canvas1.getContext('2d');
			let canvasContext2 = canvas2.getContext('2d');
			let canvasContext3 = canvas3.getContext('2d');
			canvas1.width = audioAnalyser.frequencyBinCount;	//spectrums.length;
			canvas1.height = 256;
			canvas2.width = audioAnalyser.frequencyBinCount;	//spectrums.length;
			canvas2.height = 256;
			
			let time = {
				process : {
					pre : audioContext.currentTime,
					delta : {
						value : null,
						mean : null,
						median : null,
						stdev : null,
						updateStat : createStat(15),
					},
				},
				sync : {
					pre : audioContext.currentTime,
					delta : {
						value : null,
						mean : null,
						median : null,
						stdev : null,
						updateStat : createStat(15),
					},
				},
			};
			let num = {
				sync : {
					value : null,
					mean : null,
					median : null,
					stdev : null,
					updateStat : createStat(10),
				},
				data : {
					value : null,
					mean : null,
					median : null,
					stdev : null,
					updateStat : createStat(10),
					result : null,
				},
				check : {
					value : null,
					mean : null,
					median : null,
					stdev : null,
					updateStat : createStat(10),
					result : null,
				},
			};
			let state = 0;	// 0:未受信, 1:同期信号受信開始, 2:同期信号受信完了(ビットレベルの同期), 3:同期ワード受信完了(バイトレベルの同期), 4:ヘッダ受信開始, 5:ヘッダ受信完了, 6:データ受信開始, 7:データ受信終了
			let syncSign = -1;	// 上昇or下降
			let fields = {};
			let binId = "";
			let binSize = 0;
			//let binRawByte = "";
			let binDecodeByte = "";
			let binRawData = "";
			let binDecodeData = "";
			
			scriptProcessor.onaudioprocess = function(e){
				// 時間を計測
				time.process.delta.value = audioContext.currentTime - time.process.pre;
				time.process.delta.updateStat(time.process.delta.value);
				time.process.pre = audioContext.currentTime;
				document.querySelector("#time_process_value").innerText = time.process.delta.value;
				document.querySelector("#time_process_mean").innerText = time.process.delta.mean;
				document.querySelector("#time_process_median").innerText = time.process.delta.median;
				document.querySelector("#time_process_stdev").innerText = time.process.delta.stdev;
				
				// 波形を解析
				let timeDomain = new Uint8Array(audioAnalyser.fftSize);	// 音声波形データ	fftSizeの大きさで格納されている
				audioAnalyser.getByteTimeDomainData(timeDomain);
				let spectrums = new Uint8Array(audioAnalyser.frequencyBinCount);	// 周波数データ(frequencyBinCountはfftSizeの半分)
				audioAnalyser.getByteFrequencyData(spectrums);
				// getFloatFrequencyData(Float32Array array) については、信号を FFT にかけた後のマグニチュードをポイント数で割って正規化し、対数を取って dB 化した値が返されるようで、通常の音楽信号なら大体 -30 ～ -60 あたりの値が出力されます。単位は dBFS/Hz のようなもの
				// spectrumsの周波数(0～24000Hz) = sampleRate:48000 * i:0～1023 / fftSize:2048
				
				// 周波数データを表示
				document.querySelector("#bar1_19500").value = spectrums[Math.floor(19500 / fsDivN)] / 255 * 100;
				document.querySelector("#bar1_19875").value = spectrums[Math.floor(19875 / fsDivN)] / 255 * 100;
				document.querySelector("#bar1_20250").value = spectrums[Math.floor(20250 / fsDivN)] / 255 * 100;
				document.querySelector("#bar1_20625").value = spectrums[Math.floor(20625 / fsDivN)] / 255 * 100;
				document.querySelector("#bar1_21000").value = spectrums[Math.floor(21000 / fsDivN)] / 255 * 100;
				document.querySelector("#bar1_21375").value = spectrums[Math.floor(21375 / fsDivN)] / 255 * 100;
				document.querySelector("#bar1_21750").value = spectrums[Math.floor(21750 / fsDivN)] / 255 * 100;
				canvasContext1.clearRect(0, 0, canvas1.width, canvas1.height);
				for(let i=0,len=spectrums.length; i<len; i++){
					if(i * audioContext.sampleRate % audioAnalyser.fftSize == 0){	//i*fsDivN
						// 添字に対して周波数が割り切れる部分に目盛りを描画
						canvasContext1.fillStyle = "#ddd";
						canvasContext1.fillRect(i, 40, 1, canvas1.height);
						canvasContext1.fillStyle = "#999";
						canvasContext1.textAlign = "center";
						canvasContext1.fillText(i*fsDivN, i, 10+10*(i/16%4));
					}
					canvasContext1.fillStyle = "#000";
					canvasContext1.fillRect(i, canvas1.height-spectrums[i], 1, canvas1.height);
				}
				
				// 周波数データを表示
				let spectrums2 = DFT(windowfunc(timeDomain), [Math.floor(18000 / fsDivN), Math.floor(22000 / fsDivN)]);	//
				document.querySelector("#bar2_19500").value = (spectrums2.abs[Math.floor(19500 / fsDivN)] ?? 1) / 255 * 100;
				document.querySelector("#bar2_19875").value = (spectrums2.abs[Math.floor(19875 / fsDivN)] ?? 1) / 255 * 100;
				document.querySelector("#bar2_20250").value = (spectrums2.abs[Math.floor(20250 / fsDivN)] ?? 1) / 255 * 100;
				document.querySelector("#bar2_20625").value = (spectrums2.abs[Math.floor(20625 / fsDivN)] ?? 1) / 255 * 100;
				document.querySelector("#bar2_21000").value = (spectrums2.abs[Math.floor(21000 / fsDivN)] ?? 1) / 255 * 100;
				document.querySelector("#bar2_21375").value = (spectrums2.abs[Math.floor(21375 / fsDivN)] ?? 1) / 255 * 100;
				document.querySelector("#bar2_21750").value = (spectrums2.abs[Math.floor(21750 / fsDivN)] ?? 1) / 255 * 100;
				canvasContext2.clearRect(0, 0, canvas2.width, canvas2.height);
				for(let i=0,len=spectrums2.abs.length/2; i<len; i++){
					if(i * audioContext.sampleRate % audioAnalyser.fftSize == 0){	//i*fsDivN
						// 添字に対して周波数が割り切れる部分に目盛りを描画
						canvasContext2.fillStyle = "#ddd";
						canvasContext2.fillRect(i, 40, 1, canvas2.height);
						canvasContext2.fillStyle = "#999";
						canvasContext2.textAlign = "center";
						canvasContext2.fillText(i*fsDivN, i, 10+10*(i/16%4));
					}
					canvasContext2.fillStyle = "hsl(" + (spectrums2.arg[i] ?? 0) * 360 + ", 100%, " + (spectrums2.abs[i] >= 5 ? 40 : 0) + "%)";
					canvasContext2.fillRect(i, canvas2.height - (spectrums2.abs[i] ?? 1), 1, canvas2.height);
				}
				
				
				
				num.sync.value = 0;
				num.sync.value -= spectrums[Math.floor(19500/fsDivN)];
				num.sync.value += spectrums[Math.floor(19875/fsDivN)];
				num.sync.value -= spectrums[Math.floor(20625/fsDivN)];
				num.sync.value += spectrums[Math.floor(20250/fsDivN)];
				num.sync.updateStat(num.sync.value);
				
				num.data.value = 0;
				num.data.value -= spectrums[Math.floor(21375/fsDivN)];
				num.data.value += spectrums[Math.floor(21750/fsDivN)];
				num.data.updateStat(num.data.value);
				num.data.result = (num.data.mean > 0) * 1;
				
				//num.check.value = spectrums[Math.floor(21800/fsDivN)] - spectrums[Math.floor(21700/fsDivN)];
				//num.check.updateStat(num.check.value);
				//num.check.result = (num.check.mean > 0) * 1;
				
				document.querySelector("#sync_value").innerText = num.sync.value;
				document.querySelector("#sync_mean").innerText = num.sync.mean;
				document.querySelector("#sync_median").innerText = num.sync.median;
				document.querySelector("#sync_stdev").innerText = num.sync.stdev;
				
				document.querySelector("#data_value").innerText = num.data.value;
				document.querySelector("#data_mean").innerText = num.data.mean;
				document.querySelector("#data_median").innerText = num.data.median;
				document.querySelector("#data_stdev").innerText = num.data.stdev;
				
				if(Math.sign(syncSign) === Math.sign(num.sync.mean)){
					
					syncSign += Math.sign(syncSign);
					if(Math.abs(syncSign) >= 7){			// 同じ符号が連続で続いた場合
						syncSign = -Math.sign(syncSign);	// 符号を反転させる
						
						// 時間を計測	同期信号取得中
						time.sync.delta.value = audioContext.currentTime - time.sync.pre;
						time.sync.delta.updateStat(time.sync.delta.value);
						time.sync.pre = audioContext.currentTime;
						document.querySelector("#time_sync_value").innerText = time.sync.delta.value;
						document.querySelector("#time_sync_mean").innerText = time.sync.delta.mean;
						document.querySelector("#time_sync_median").innerText = time.sync.delta.median;
						document.querySelector("#time_sync_stdev").innerText = time.sync.delta.stdev;
						
						if(state === 0 && time.sync.delta.stdev < 100){
							state++;
						}
						
						if(time.sync.delta.stdev < 0.1){	// 同期信号の切り替え間隔の標準偏差が0.1未満の場合、同期信号取得成功
							binRawData += num.data.result;
							document.querySelector("#dataResult").innerText = num.data.result;
							
							if(state === 6){
								document.querySelector("#out_binary").innerText += num.data.result;
							}
							
							if(state === 1){
								// ビットレベル同期完了
								state++;
							}
							else if(state === 2){
								if(decodeExHamming(binRawData.slice(-8)) == "0110"){	// 0110 decode> 01101100:'l'
									// バイトレベル同期完了(開始フレーム識別子(SFD)受信)
									state = 3;
									binRawData = "";
								}
							}
							else if(state >= 3 && state <= 6){
								document.querySelector("#out_log0").textContent += num.data.result + (binRawData.length%4 ? "":" ");

								if(binRawData.length % 8 === 0){	// 8ビット単位で処理
									binDecodeByte = decodeExHamming(binRawData.slice(-8));
									binDecodeData += binDecodeByte;

									document.querySelector("#out_log1").innerHTML += (state%2 ? "head":"body");
									document.querySelector("#out_log1").innerHTML += "&nbsp;-&nbsp;raw:" + binRawData.slice(-8);
									document.querySelector("#out_log1").innerHTML += ",&nbsp;decode:" + encodeExHamming(binDecodeByte);
									
									if(state === 3 || state === 5){
										binId = binDecodeByte;
										binSize = parseInt(encodeExHamming(binDecodeByte).slice(-4), 2) - 1;
										//document.querySelector("#out_log1").innerHTML += ",&nbsp;decode:" + encodeExHamming(binDecodeByte);
										switch(binId){
											case "0110":	// 0110 decode> 01101100:'l'
												state = 3;
												binSize = 0;
												break;
											case "0111":	// 0111 decode> 01110010:'r'
												state = 4;
												break;
											case "0011":	// 0011 decode> 00110101:'5'
												state = 4;
												break;
											case "0101":	// 0101 decode> 01011001:'Y'
												state = 6;
												binSize = parseInt(fields["0011"], 2) - 1;
												break;
											//case "0010":	// 0010 decode> 00101011:'+'
												//state = 8;
												//break;
											default:
												document.querySelector("#out_log1").innerHTML += "&nbsp;error!";
												break;
										}
										document.querySelector("#field_name").innerText = encodeExHamming(binDecodeByte);	//binRawData.slice(-8)
										document.querySelector("#field_size").innerText = binSize;
										binRawData = "";
										binDecodeData = "";
									}
									else if(state === 4 || state === 6){
										
										if(state === 6){		// ペイロード受信中
											document.querySelector("#out_hex").innerText += parseInt(binDecodeByte, 2).toString(16);
											
											if(decode(binDecodeData, 2) != ""){
												document.querySelector("#out_text").value = decode(binDecodeData, 2);
											}
											else{
												document.querySelector("#out_text").value += decode(binDecodeByte, 2);
											}
										}
										
										binSize--;
										document.querySelector("#field_size").innerText = binSize;
										if(binSize === 0){	// フィールド受信終了
											fields[binId] = binDecodeData;
											//document.querySelector("#out_log1").innerHTML += " ┗ " + binRawData + "<br />";
											binRawData = "";
											binDecodeData = "";
											state++;
										}
									}

									document.querySelector("#out_log1").innerHTML += "<br />";
									document.querySelector("#out_log1").scrollIntoView(false);
									document.querySelector("#out_log1").scrollTo(0, document.querySelector("#out_log1").scrollHeight);
								}
							}
							
							
						}
						document.querySelector("#status").innerText = state;
					}
					document.querySelector("#syncSign").innerText = syncSign;
				}
				
				
				
				// 位相データを表示
				canvasContext3.clearRect(canvas3.dataset.count, 0, 20, canvas3.height);
				//canvasContext3.fillRect(canvas3.dataset.count, canvas3.height / 2 - (spectrums2.arg[Math.floor(20250 / fsDivN)] ?? 0) * 100, 1, 2);
				canvasContext3.fillRect(
					canvas3.dataset.count,
					canvas3.height / 2 - (
						(spectrums2.arg[Math.floor(18000 / fsDivN)] ?? 0)
						-(spectrums2.arg[Math.floor(18750 / fsDivN)] ?? 0)
					) * 100,
					1,
					2
				);	// 同期信号の位相データと比較
				canvas3.dataset.count = (canvas3.dataset.count*1 + 1) % canvas3.width;
				
				
				
				
				// 同期信号を表示
				canvasContext0.clearRect(canvas0.dataset.count, 0, 20, canvas0.height);
				canvasContext0.globalCompositeOperation = "multiply";	//lighter
				canvasContext0.fillStyle = "#666";
				canvasContext0.fillRect(canvas0.dataset.count, canvas0.height/2 - num.sync.value, 1, num.sync.value);
				if(canvas0.dataset.count == 0){
					//canvasContext0.lineWidth = 1;
					canvasContext0.strokeStyle = "#00f";
					canvasContext0.beginPath();
					canvasContext0.moveTo(1, canvas0.height/2);
				}
				else{
					canvasContext0.lineTo(canvas0.dataset.count, canvas0.height/2 - num.sync.mean);
					canvasContext0.stroke();
					canvasContext0.beginPath();
					canvasContext0.moveTo(canvas0.dataset.count, canvas0.height/2 - num.sync.mean);
				}
				canvas0.dataset.count = (canvas0.dataset.count*1 + 1) % canvas0.width;
				
				
				
				//document.querySelector("#out_log1").innerText = num.sync.median;
				//document.querySelector("#out_log1").innerText += (audioContext.currentTime - t) + "<br />";
			};
			
			scriptProcessor.connect(audioContext.destination);
			
			mediaStreamSource.connect(scriptProcessor);
			mediaStreamSource.connect(audioAnalyser);
		},
		function(err){
			// エラー処理
		}
	);
}


window.addEventListener("load", function(){
	
	/*
	Array(16).fill(0).forEach((e, i) => {
		let s = encodeHamming((i).toString(2).padStart(4, 0).split(""));
		document.querySelector("#out_log1").innerHTML += s + " " + decode(s, 2) + "<br />";
	});
	// */
	
	/*
	data+EHam
	0010 1011	+
	0011 0101	5
	0100 0111	G
	0101 1001	Y
	0110 1100	l
	0111 0010	r
	// */
});

window.addEventListener("unload", function(){
	
});


// ]]>
</script>
</head>
<body>
<main>


<details>
	<summary>send</summary>
	<div>
		<textarea id="in">&lt;&lt;333UUあ</textarea>
		<!--input type="text" value="`Q ab cあ-いう" id="in" /-->
		<br />
		<input type="button" value="send" onclick="send(this.parentNode.firstChild.nextSibling.value);" />
		<input type="button" value="encode" onclick="alert(encode(this.parentNode.firstChild.nextSibling.value,16).toString());" />
		<div id="in_progressive"></div>
	</div>
</details>

<br />

<details>
	<summary>receive</summary>
	<div>
		<input type="button" value="receive" onclick="receive();" />
		<br />
		<div id="out_log0" class="dashed"></div>
		<div id="out_log1"></div>
		<div class="dashed">
			<div id="out_binary"></div>
			<div id="out_hex"></div>
			<textarea id="out_text"></textarea>
		</div>
		<div>
			<span title="1:「+」, -1:「-」">
				sync-sign : <span id="syncSign">0</span>
			</span>
			<br />
			<span>
				data : <span id="dataResult">0</span>
			</span>
			<br />
			<span title="0:未受信, 1:同期信号受信開始, 2:同期信号受信完了(ビットレベルの同期), 3:同期ワード受信完了(バイトレベルの同期), 4:ヘッダ受信開始, 5:ヘッダ受信完了, 6:データ受信開始, 7:データ受信終了">
				status : <span id="status">0</span>
			</span>
			<br />
			<span>
				field-name : <span id="field_name">0</span>
			</span>
			<br />
			<span>
				field-size : <span id="field_size">0</span>
			</span>
			<br />

			<table class="statistics">
				<tr>
					<td></td>
					<td>value</td>
					<td>mean</td>
					<td>median</td>
					<td>standard deviation</td>
				</tr>
				<tr>
					<td>time-process-delta</td>
					<td id="time_process_value">0</td>
					<td id="time_process_mean">0</td>
					<td id="time_process_median">0</td>
					<td id="time_process_stdev">0</td>
				</tr>
				<tr>
					<td>time-sync-delta</td>
					<td id="time_sync_value">0</td>
					<td id="time_sync_mean">0</td>
					<td id="time_sync_median">0</td>
					<td id="time_sync_stdev" class="dashed">0</td>
				</tr>
				<tr>
					<td>num-sync</td>
					<td id="sync_value">0</td>
					<td id="sync_mean" class="dashed">0</td>
					<td id="sync_median">0</td>
					<td id="sync_stdev">0</td>
				</tr>
				<tr>
					<td>num-data</td>
					<td id="data_value">0</td>
					<td id="data_mean" class="dashed">0</td>
					<td id="data_median">0</td>
					<td id="data_stdev">0</td>
				</tr>
			</table>
		</div>
		<br />
		
		<div style="display:inline-block; font-family:monospace;">
			<!--
			18000 <meter max="100" value="0" id="bar1_18000"></meter><br />
			18375 <meter max="100" value="0" id="bar1_18375"></meter><br />
			18750 <meter max="100" value="0" id="bar1_18750"></meter><br />
			19125 <meter max="100" value="0" id="bar1_19125"></meter><br />
			-->
			19500 <meter max="100" value="0" id="bar1_19500"></meter><br />
			19875 <meter max="100" value="0" id="bar1_19875"></meter><br />
			20250 <meter max="100" value="0" id="bar1_20250"></meter><br />
			20625 <meter max="100" value="0" id="bar1_20625"></meter><br />
			21000 <meter max="100" value="0" id="bar1_21000"></meter><br />
			21375 <meter max="100" value="0" id="bar1_21375"></meter><br />
			21750 <meter max="100" value="0" id="bar1_21750"></meter><br />
			<!--
			22125 <meter max="100" value="0" id="bar1_22125"></meter><br />
			22500 <meter max="100" value="0" id="bar1_22500"></meter><br />
			22875 <meter max="100" value="0" id="bar1_22875"></meter><br />
			-->
		</div>
		<div style="display:inline-block; font-family:monospace;">
			<!--
			18000 <meter max="100" value="0" id="bar2_18000"></meter><br />
			18375 <meter max="100" value="0" id="bar2_18375"></meter><br />
			18750 <meter max="100" value="0" id="bar2_18750"></meter><br />
			19125 <meter max="100" value="0" id="bar2_19125"></meter><br />
			-->
			19500 <meter max="100" value="0" id="bar2_19500"></meter><br />
			19875 <meter max="100" value="0" id="bar2_19875"></meter><br />
			20250 <meter max="100" value="0" id="bar2_20250"></meter><br />
			20625 <meter max="100" value="0" id="bar2_20625"></meter><br />
			21000 <meter max="100" value="0" id="bar2_21000"></meter><br />
			21375 <meter max="100" value="0" id="bar2_21375"></meter><br />
			21750 <meter max="100" value="0" id="bar2_21750"></meter><br />
			<!--
			22125 <meter max="100" value="0" id="bar2_22125"></meter><br />
			22500 <meter max="100" value="0" id="bar2_22500"></meter><br />
			22875 <meter max="100" value="0" id="bar2_22875"></meter><br />
			-->
		</div>
		<br />
		
		<canvas id="canvas0" width="500" height="200" data-count="0"></canvas>
		<canvas id="canvas1" width="256" height="256"></canvas>
		<canvas id="canvas2" width="256" height="256"></canvas>
		<canvas id="canvas3" width="500" height="200" data-count="0"></canvas>
		<br />
	</div>
</details>

</main>

</body>
</html>
